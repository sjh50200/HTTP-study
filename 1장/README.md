# 1장 - HTTP 개관

---

# 주제

- 얼마나 많은 클라이언트와 서버가 통신하는지
- 리소스 (웹 콘텐츠)가 어디서 오는지
- 웹 트랜잭션이 어떻게 동작하는지
- HTTP 통신을 위해 사용하는 메시지의 형식
- HTTP 기저의 TCP 네트워크 전송
- 여러 종류의 HTTP 프로토콜
- 인터넷 곳곳에 설치된 다양한 HTTP 구성요소

## 1.2 웹 클라이언트와 서버

웹 콘텐츠는 웹 서버에 존재한다.

예를 들어, “http://www.oreilly.com/index.html 페이지를 열어볼 때,

웹 브라우저는 HTTP요청을 www.oreily.com 서버로 보낸다.

서버는 요청 받은 객체 /index.html 를 찾고, 성공했다면 그 것의 타입, 길이등의 정보와 함께 HTTP 응답에 실어서 클라이언트에게 보낸다.

## 1.3 리소스

웹 리소스는 웹 콘텐츠의 원천이다.

가장 단순한 웹 리소스는 정적 파일

- .txt, .html, .word, .jpeg, .avi ...

리소스는 요청에 따라 콘텐츠를 생산하는 동적인 파일이 될 수도 있다.

- 사용자가 누구인지, 어떤 정보를 요청했는 지 등에 따라 다른 콘텐츠를 생성

⇒ 어떠한 종류의 콘텐츠도 리소스가 될 수 있다.

### 1.3.1 미디어 타입

**인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 MIME 타입이라는 데이터 포맷 라벨을 붙인다.**

- MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장)
    
    원래는 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해서 설계 되었음.
    
    이메일에서 워낙 잘 동작했기 때문에, HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨링 하기 위해 채택됨.
    
    - 사선(/)으로 구분된 주 타입과 부 타입으로 이루어진 문자열 라벨
        
        ex) image/jpeg, text/html, image/gif ...
        

웹 서버는 MIME 타입을 모든 객체 데이터에 붙이고 ↔  브라우저는 MIME 타입을 통해 다룰 수 있는지 확인

### 1.3.2 URI

웹 서버 리소스는 각자의 이름을 가지고 있다. 클라이언트는 관심 있는 리소스를 지목 가능!

이 이름을 통합 자원 식별자(Uniform Resource Identifier, **URI**)라고 칭함.

URI에는 URL과 URN이 존재

- ‘죠의 컴퓨터 가게'의 웹 서버에 있는 이미지 리소스에 대한 URI
    
    ⇒ http://www.joes-hardware.com/specials/sawblade.gif
    
    - URI 해석 과정
    
    | http:// | HTTP 프로토콜을 사용하라 |
    | --- | --- |
    | www.joes-hardware.com | www.joes-hardware.com으로 이동하라 |
    | /specials/saw-blade.gif | /specials/saw-blade.gif라고 불리는 리소스를 가져와라 |

### 1.3.3 URL

통합 자원 지시자(Uniform Resource Locator, URL)는 리소스 식별자의 가장 흔한 형태

- 특정 서버의 한 리소스에 대한 구체적인 위치를 서술
- 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려줌.
    
    ex)
    
    | URL | 설명 |
    | --- | --- |
    | http://www.oreily.com/index.html | 오라일리 출판사 홈페이지의 URL |
    | http://www.yahoo.com/images/logo.gif | 야후 웹 사이트 로고의 URL |
    | http://www.joes-hardware.com/inventory-check.cgi?item=12731 | 물품 #12371의 재고가 있는지 확인하는 프로그램에 대한 URL |

**오늘날 대부분의 URI는 URL임.**

### 1.3.4 URN

유니폼 리소스 이름(unifor resource name, URN)이다.

리소스에 대해, 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 한다.

- ex) ‘RFC 2141’가 어디에 있거나 상관 없이 지칭 하는 이름
    
    urn:ietf:rfc:2141
    

여전히 실험 중인 상태고 널리 채택되지 않았음.

## 1.4 트랜잭션

HTTP 트랜잭션은 요청 명령과 응답 결과로 구성되어 있다.

### 1.4.1 메서드

HTTP 요청 메시지는 한 개의 메서드를 가짐.

- 서버에게 어떤 동작이 취해져야 하는지 말해준다(웹페이지 가져오기, 파일 삭제하기 등)
    
    
    | HTTP 메서드 | 설명 |
    | --- | --- |
    | GET | 서버에서 클라이언트로 지정한 리소스를 보내라. |
    | PUT | 클라이언트에서 서버로 보낸 데이터를 지정한 리소스로 저장하라. |
    | DELETE | 지정한 리소스를 서버에서 삭제하라. |
    | POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라. |
    | HEAD | 지정한 리소스에 대한 응답에서, HTTP헤더 부분만 보내라. |

3장에서 더 자세히 다룸

[](https://www.notion.so/3-04ec7a51e46949f3afa96cc6737ec97a)

### 1.4.2 상태 코드

모든 HTTP 응답 메시지는 상태 코드와 함께 반환된다.

상태코드도 3장에서 더 자세히...

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다.

애플리케이션은 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행한다. 이 리소스들은 각 기ㄱ른 서버에 위치할 수도 있다.

이와 같이 ‘웹페이지'는 보통 하나의 리소스가 아닌 리소스의 모음이다.

## 1.5 메시지

- 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽다.
- 세 부분으로 이루어져 있음
    1. 시작줄
        
        ⇒ 요청이라면 무엇을 해야 하는지 응답이라면 무슨 일이 일어났는지 나타낸다.
        
        ex) 요청: GET /test/hi-there.txt HTTP/1.0 or 응답: HTTP/1.0 200 OK
        
    2. 헤더
        
        ⇒ key: value 구조의 필드
        
        ex) 요청: Accept: text/*... or 응답: content-type: text/plain ...
        
    3. 본문
        
        ⇒ 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 오게 된다.
        
        ex) “Hi!”, hi.jpeg, hi.avi ...
        

## 1.6 TCP 커넥션

### 1.6.1 TCP/IP

- 오류 없는 데이터 전송
- 순서에 맞는 전달 (데이터의 송신 순서와 수신 순서가 같다)
- 조각나지 않는 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있다)

인터넷 자체가 TCP/IP에 기초하고 있으며 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합이다.

각 네트워크와 하드웨어 특성을 숨기고, 어떤 종류 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해 준다.

TCP는 4단계(전송 계층), IP는 3단계(네트워크 계층)이다.

### 1.6.2 접속, IP 주소 그리고 포트번호

HTTP 클라이언트가 서버에 메시지를 전송하려면, 인터넷 프로토콜(IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.

서버 IP 주소와 포트번호는 어디에 있나?

⇒ URL을 이용하면 된다. 리소스에 대한 주소이기 때문에 당연히 장비에 대한 IP 주소를 알려줄 수 있다.

**과정**

ex) http:// www.netscape.com/index.html

- DNS를 통해 www.netscape.com의 IP를 알아냄
- 포트 번호가 빠진 경우에는 기본값 80이라고 가정하면 된다.

큰 틀로 순서를 보자면

<aside>
💡 a. 웹 브라우저는 서버의 URL에서 호스트명을 추출한다.
b. 웹 브라우저는 서버의 호스트 명을 IP로 변환한다.
c. 웹 브라우저는 URL에서 포트번호(있다면)를 추출한다.
d. 웹 브라우저는 웹 서버와 TCP 커넥션을 맺는다.
e. 웹 브라우저는 서버에 HTTP 요청을 보낸다.
f. 서버는 웹 브라우저에 HTTP 응답을 돌려준다.
g. 커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

</aside>

## 1.7 프로토콜 버전

오늘날 쓰이고 있는 HTTP 프로토콜은 버전이 여러 가지임. 변형을 잘 다루려면 HTTP 어플리케이션이 일을 열심히 해야 함.

### HTTP/0.9

- 1991년 출시
- 심각한 디자인 결함이 다수 있고 구식 클라이언트하고만 사용 가능
- *오직 GET 메서드 지원, MIME 타입, HTTP 헤더 지원 X*
- 간단한 HTML 객체를 받기 위해 만들어진 것

### HTTP/1.0

- 1.0은 처음으로 널리 쓰이기 시작한 버전
- *버전 번호, HTTP헤더, 추가 메서드, 멀티미디어 객체 처리 추가*
- world wide web을 대세로 만들었음.
- **잘 정의된 명세라기보단 상업정, 학술적으로 급성장하던 시기에 만들어진, 잘 동작하는 용례의 모음**

### HTTP/1.0+

- 1990년대 중반, 웹이 급격히 팽창하고 상업적 성공에 따라 그에 따른 요구를 만족시키기 위해 기능 추가
- *keep-alive 커넥션, 가상 호스팅 지원, 프락시 연결 지원*
- 외의 확장된 HTTP 버전을 흔히 이 버전으로 부른다.

### HTTP/1.1

- *구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거*
- 더 복잡해진 웹 앱과 배포(1990년 후반에 이미 쓰이고 있었음)를 지원
- **현재의 HTTP 버전**

### HTTP/2.0

- 1.1의 성능 문제를 개선하기 위해
- 구글의 SPDY 프로토콜을 기반으로 설계가 진행 됨.

## 1.8 웹의 구성요소

### 1.8.1 프락시

- 클라이언트와 서버 사이에 위치한 HTTP 중개자

**성능 최적화를 위한 중요한 구성 요소인 HTTP 프락시 서버**

클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달한다.

사용자를 대신해서 서버에 접근한다.

주로 보안을 위해 사용되는데, 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 하며, 요청과 응답을 필터링한다.

⇒ 회사에서 무언가를 다운 받을 때 어플 바이러스 검출 or 초등학교 학생들에게서 성인 콘텐츠 차단

### 1.8.2 캐시

- 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고

**웹캐시와 캐시 프락시는** 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, 특별한 종류의 HTTP 프락시 서버.

멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 빨리 문서를 받을 수 있음.

### 1.8.3 게이트웨이

- 다른 애플리케이션과 연결된 특별한 웹 서버

다른 서버들의 중개자로 동작하는 특별한 서버다. **주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용된다.**

스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다. 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못할 것임.

### 1.8.4 터널

- 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시

터널은 두 커넥션 사이에서 raw한 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션.

⇒ 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시킴.

1. HTTP/SSL 터널은 HTTP 요청을 받아들여 목적지의 주소와 포트번호로 커넥션을 맺는다.
2. 암호화된 SSL 트래픽을 HTTP 채널을 통해 목적지 서버로 전송할 수 있게 된다.

### 1.8.5  에이전트

- 자동화된 HTTP 요청을 만드는 준지능적(semi-intelligent) 웹 클라이언트

사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램이다.

⇒ 웹 브라우저, 스파이더, 웹 로봇